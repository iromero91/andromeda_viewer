#ifndef TOOL_BASE_H
#define TOOL_BASE_H

#include <QDebug>

/*
 * Drawing tools are used to handle sequential drawing steps.
 * Each drawing tool keeps an internal state machine and handles the specifics of its own drawing
 * The drawing tool gets added to the scene
 */

#include <QObject>
#include <QPainter>
#include <QPen>
#include <QBrush>
#include <QApplication>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QString>

#include "src/base/object_names.h"

#include "tool_defines.h"

class AToolBase : public QObject
{
    Q_OBJECT

    Q_PROPERTY( QString toolName READ toolName )
    Q_PROPERTY( QPointF toolPos READ toolPos WRITE setToolPos )
    Q_PROPERTY( TOOL_STATE toolState READ toolState WRITE setToolState )
    Q_PROPERTY( bool active READ isActive STORED false )
    Q_PROPERTY( bool finished READ isFinished STORED false )

public:
    AToolBase(QObject *parent = 0);

    // Tool status functions
    bool isActive(void) { return (tool_state_ > TOOL_STATE::INACTIVE); }
    bool isFinished(void) { return (tool_state_ == TOOL_STATE::FINISHED); }

    TOOL_STATE toolState(void) { return tool_state_; }
    QPointF toolPos() { return tool_pos_; }
    QString toolName(void) { return objectName(); }

    /*
     * Paint Functions:
     *
     * paint() is called from the AView:: that owns this tool
     *
     * Do not override paint(), instead override paintTool() and paintHints()
     *
     * In general:
     * paintTool() is for displaying what has been generated "so far"
     * paintHints() is for displaying what will be generated by the next user action
     */
    void paint(QPainter *painter, const QRectF &rect);
    virtual void paintTool(QPainter *painter, const QRectF &rect) { Q_UNUSED(painter); Q_UNUSED(rect); }
    virtual void paintHints(QPainter *painter, const QRectF &rect) { Q_UNUSED(painter); Q_UNUSED(rect); }

public slots:
    /*
     * Tool slots should (in general) not be overridden by child classes
     * Each slot performs some generic action and then calls a virtual callback
     * e.g. start(void) -> onStart(void)
     * So, the child class should implement onStart if it needs to
     */

    // State machine functions
    //!< Start the tool
    void start(void);
    //!< Cancel (stop) the tool
    void cancel(void);
    //!< Reset tool to default state
    void reset(void);
    //!< Finsh the tool action
    void finish(void);

    //! Function for natural progression of the tool
    //! Actual implementation depends on the tool
    virtual void nextAction(void) {}

    //! Function for performing the 'final action' of the tool
    virtual void finalAction(void) {}

    // Event functions
    // In addition to passing the event, the current cursor position is also provided
    void mouseEvent(QMouseEvent *event, QPointF cursorPos);
    void keyEvent(QKeyEvent *event, QPointF cursorPos);

    void setToolState(TOOL_STATE state) { tool_state_ = state; }
    void setToolPos(QPointF pos)
    {
        tool_pos_ = pos;
        onToolPosChanged();
        emit updated();
    }

signals:
    /*
     * Tool signals
     * These signals are emitted as the tool state machine changes
     */
    void finished(void);    // Emitted when the tool completes
    void cancelled(void);   // Emitted when the tool is cancelled
    void updated(void);     // Emitted when the tool should be repainted

protected:
    // Tool state machine
    TOOL_STATE tool_state_ = TOOL_STATE::INACTIVE;

    // Current tool position
    QPointF tool_pos_;

    // Overridable state-machine callbacks
    virtual void onStart(void)          {}
    virtual void onCancel(void)         {}
    virtual void onReset(void)          {}
    virtual void onFinish(void)         {}
    virtual void onToolPosChanged(void) {}

    // Overridable UI event callbacks
    virtual void onMouseEvent(QMouseEvent *event) { Q_UNUSED(event); }
    virtual void onKeyEvent(QKeyEvent *event)     { Q_UNUSED(event); }

    QPen hints_pen_;
    QPen tool_pen_;
    QBrush tool_brush_;

    void defaultPens(void);
};

#endif // TOOL_BASE_H

